/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright by The HDF Group.                                               *
 * All rights reserved.                                                      *
 *                                                                           *
 * This file is part of AXE.  The full AXE copyright notice, including terms *
 * governing use, modification, and redistribution, is contained in the file *
 * COPYING at the root of the source code distribution tree.                 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "axe_test.h"
#include "AXEid.h"
#include <limits.h>


/*
 * Macros
 */
/* "Phase" of id - whether it has been generated but not inserted, inserted, or
 * removed */
#define TEST_ID_PHASE_GEN   0
#define TEST_ID_PHASE_INS   1
#define TEST_ID_PHASE_REM   2

/* Minimum and maximmum ids for AXE_id_generate() */
#define TEST_ID_MIN_ID      0
#define TEST_ID_MAX_ID      (INT_MAX / 2)

#ifdef TEST_EXPRESS
#define GENERATE_NITER      100
#define INSERT_GEN_NITER    100
#define INSERT_NOGEN_NITER  100
#define LOOKUP_GEN_NITER    200
#define LOOKUP_INS_NITER    200
#define REMOVE_GEN_NITER    100
#define REMOVE_INS_NITER    100
#define ITERATE_NITER       20
#define OUTER_NITER         10
#else /* TEST_EXRESS */
#define GENERATE_NITER      1000
#define INSERT_GEN_NITER    1000
#define INSERT_NOGEN_NITER  1000
#define LOOKUP_GEN_NITER    2000
#define LOOKUP_INS_NITER    2000
#define REMOVE_GEN_NITER    1000
#define REMOVE_INS_NITER    1000
#define ITERATE_NITER       200
#define OUTER_NITER         50
#endif /* TEST_EXPRESS */


/*
 * Typedefs
 */
/* Struct describing a single id used by this test */
typedef struct test_id_elem_t {
    OPA_Queue_element_hdr_t queue_hdr;  /* Header for insertion into queues in shared struct below */
    AXE_id_t            id;             /* id */
    OPA_int_t           phase;          /* Phase of id (see TEST_ID_PHASE_*) */
    _Bool               checked;        /* Whether the id has been checked by the post-test analysis code */
} test_id_elem_t;

/* Shared data for all threads */
typedef struct test_id_shared_t {
    AXE_id_table_t      *id_table;      /* The id table the test operates on */
    OPA_Queue_info_t    gen_queue;      /* Queue of ids that have been generated but not inserted */
    pthread_mutex_t     gen_queue_mutex; /* Mutex for dequeueing from gen_queue */
    OPA_Queue_info_t    ins_queue;      /* Queue of ids that have been inserted */
    pthread_mutex_t     ins_queue_mutex; /* Mutex for dequeueing from ins_queue */
    OPA_Queue_info_t    rem_queue;      /* Queue of ids that have been removed.  No mutex is necessary because ids are only dequeued in the (single threaded) post test analysis */
    OPA_int_t           next_nogen;     /* Next id to use for manual (non-generated) insertion */
    OPA_int_t           num_gen;        /* Number of ids generated by AXE_id_generate() */
    OPA_int_t           num_ins_gen;    /* Number of generated ids that have been inserted */
    OPA_int_t           num_ins_nogen;  /* Number of non-generated ids that have been inserted */
    OPA_int_t           num_rem_gen;    /* Number of generated but not inserted ids that have been removed */
    OPA_int_t           num_rem_ins;    /* Number of inserted ids that have been removed */
    OPA_int_t           ncomplete;      /* Number of tasks that have completed */
    OPA_int_t           nfailed;        /* Number of tasks that have failed */
    int                 iter_reduction; /* Factor to reduce number of iterations by */
} test_id_shared_t;


/*
 * Variables
 */
/* Perform each test for each combination of elements in num_threads_g and
 * num_buckets_g.  The number of simultaneous threads is given by num_threads_g
 * ,the number of hash buckets in the id table is given by num_buckets_g, and
 * the number of hash bucket mutexes is given by num_mutexes_g.  The element
 * selected in num_mutexes_g always has the same index as that in num_buckets_g.
 * Therefore, num_buckets_g and num_mutexes_g must be the same length. */
size_t num_threads_g[] = {1, 4, 16};
size_t num_buckets_g[] = {10, 10000};
size_t num_mutexes_g[] = {2, 100};

/* For the number of threads corresponding to the same location in
 * num_threads_g, reduce the number of iterations by the factor idicated in this
 * array */
int iter_reduction_threads_g[] = {2, 1, 1};

/* For the number of buckets corresponding to the same location in
 * num_buckets_g, reduce the number of iterations by the factor
 * indicated in this array */
int iter_reduction_buckets_g[] = {8, 1};

/* Definitions needed for limiting the maximum number of threads */
MAX_NTHREADS_DECL;


/*-------------------------------------------------------------------------
 * Function:    test_id_generate_helper
 *
 * Purpose:     Repeatedly generates ids with AXE_id_generate() and adds
 *              them to gen_queue.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_generate_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    int i;

    /* Repeatedly generate ids and add them to gen_queue */
    for(i = 0; i < (GENERATE_NITER / shared->iter_reduction); i++) {
        /* Allocate and initialize elem */
        if(NULL == (elem = (test_id_elem_t *)malloc(sizeof(test_id_elem_t))))
            TEST_ERROR;
        OPA_Queue_header_init(&elem->queue_hdr);
        OPA_store_int(&elem->phase, TEST_ID_PHASE_GEN);
        elem->checked = FALSE;

        /* Generate id */
        if(AXE_id_generate(shared->id_table, &elem->id) != AXE_SUCCEED)
            TEST_ERROR;
        OPA_incr_int(&shared->num_gen);

        /* Write barrier to make sure elem is filled out before other threads
         * can access it */
        OPA_write_barrier();

        /* Add to generated queue */
        OPA_Queue_enqueue(&shared->gen_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_generate_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_insert_gen_helper
 *
 * Purpose:     Repeatedly retrieves ids from gen_queue, inserts them into
 *              id_table, and adds them to ins_queue.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_insert_gen_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    int i;

    /* Repeatedly insert objects using generated ids and add them to ins_queue
     */
    for(i = 0; i < (INSERT_GEN_NITER / shared->iter_reduction); i++) {
        /* Lock gen_queue_mutex */
        if(0 != pthread_mutex_lock(&shared->gen_queue_mutex))
            TEST_ERROR;

        /* Retrieve generated element from queue.  If the queue is empty,
         * return. */
        if(OPA_Queue_is_empty(&shared->gen_queue)) {
            if(0 != pthread_mutex_unlock(&shared->gen_queue_mutex))
                TEST_ERROR;
            break;
        } /* end if */

        /* Dequeue element */
        OPA_Queue_dequeue(&shared->gen_queue, elem, test_id_elem_t, queue_hdr);
        assert(elem);

        /* Modify element phase */
        if(TEST_ID_PHASE_GEN != OPA_swap_int(&elem->phase, TEST_ID_PHASE_INS))
            TEST_ERROR;

        /* Unlock gen_queue_mutex */
        if(0 != pthread_mutex_unlock(&shared->gen_queue_mutex))
            TEST_ERROR;

        /* Insert elem into table */
        if(AXE_id_insert(shared->id_table, elem->id, elem, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        OPA_incr_int(&shared->num_ins_gen);

        /* Write barrier to make sure elem is really in the table before we add
         * it to the inserted queue */
        OPA_write_barrier();

        /* Add to inserted queue */
        OPA_Queue_enqueue(&shared->ins_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_insert_gen_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_insert_gen_helper
 *
 * Purpose:     Repeatedly manually generates ids using next_nogen,
 *              inserts them into id_table, and adds them to ins_queue.
 *              When half of the total non-generated inserts are complete,
 *              this function instead uses TEST_ID_MAX_ID as the id,
 *              causing id_table to become "wrapped" - using an exhaustive
 *              serach for free ids in AXE_id_generate().
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_insert_nogen_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    int i;

    /* Repeatedly insert objects using manual ids and add them to ins_queue */
    for(i = 0; i < (INSERT_NOGEN_NITER / shared->iter_reduction); i++) {
        /* Allocate and initialize elem */
        if(NULL == (elem = (test_id_elem_t *)malloc(sizeof(test_id_elem_t))))
            TEST_ERROR;
        OPA_Queue_header_init(&elem->queue_hdr);
        OPA_store_int(&elem->phase, TEST_ID_PHASE_INS);
        elem->checked = FALSE;

        /* Increment num_ins_nogen.  If we are halfway done, deliberately "wrap"
         * the id table.  Otherwise, use the next id outside the automatic
         * range. */
        if(OPA_fetch_and_incr_int(&shared->num_ins_nogen)
                == ((INSERT_NOGEN_NITER * OUTER_NITER)
                / (shared->iter_reduction * 2)) - 1)
            /* Create a dummy element to insert.  Need to insert an element so
             * the iterate_helper test doesn't puke. */
            elem->id = TEST_ID_MAX_ID;
        else
            elem->id = (AXE_id_t)OPA_fetch_and_incr_int(&shared->next_nogen);

        /* Insert elem into table */
        if(AXE_id_insert(shared->id_table, elem->id, elem, NULL) != AXE_SUCCEED)
            TEST_ERROR;

        /* Write barrier to make sure elem is really in the table before we add
         * it to the inserted queue */
        OPA_write_barrier();

        /* Add to inserted queue */
        OPA_Queue_enqueue(&shared->ins_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_insert_nogen_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_lookup_gen_helper
 *
 * Purpose:     Repeatedly retrieves ids from gen_queue, performs
 *              AXE_id_lookup() on the id, and reinserts it into
 *              gen_queue.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_lookup_gen_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    test_id_elem_t *lookup_elem = NULL;
    int i;

    /* Repeatedly lookup objects in gen_queue and re-add them */
    for(i = 0; i < (LOOKUP_GEN_NITER / shared->iter_reduction); i++) {
        /* Lock gen_queue_mutex */
        if(0 != pthread_mutex_lock(&shared->gen_queue_mutex))
            TEST_ERROR;

        /* Retrieve generated element from queue.  If the queue is empty,
         * return. */
        if(OPA_Queue_is_empty(&shared->gen_queue)) {
            if(0 != pthread_mutex_unlock(&shared->gen_queue_mutex))
                TEST_ERROR;
            break;
        } /* end if */

        /* Dequeue element */
        OPA_Queue_dequeue(&shared->gen_queue, elem, test_id_elem_t, queue_hdr);
        assert(elem);

        /* Unlock gen_queue_mutex */
        if(0 != pthread_mutex_unlock(&shared->gen_queue_mutex))
            TEST_ERROR;

        /* Lookup element */
        if(AXE_id_lookup(shared->id_table, elem->id, (void **)(void *)&lookup_elem, NULL) != AXE_SUCCEED)
            TEST_ERROR;

        /* Verify element */
        if(lookup_elem != NULL)
            TEST_ERROR;
        if(OPA_load_int(&elem->phase) != TEST_ID_PHASE_GEN)
            TEST_ERROR;

        /* Re-add to generated queue */
        OPA_Queue_enqueue(&shared->gen_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_lookup_gen_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_lookup_ins_helper
 *
 * Purpose:     Repeatedly retrieves ids from ins_queue, performs
 *              AXE_id_lookup() on the id, and reinserts it into
 *              ins_queue.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_lookup_ins_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    test_id_elem_t *lookup_elem = NULL;
    int i;

    /* Repeatedly lookup objects in ins_queue and re-add them */
    for(i = 0; i < (LOOKUP_INS_NITER / shared->iter_reduction); i++) {
        /* Lock ins_queue_mutex */
        if(0 != pthread_mutex_lock(&shared->ins_queue_mutex))
            TEST_ERROR;

        /* Retrieve generated element from queue.  If the queue is empty,
         * return. */
        if(OPA_Queue_is_empty(&shared->ins_queue)) {
            if(0 != pthread_mutex_unlock(&shared->ins_queue_mutex))
                TEST_ERROR;
            break;
        } /* end if */

        /* Dequeue element */
        OPA_Queue_dequeue(&shared->ins_queue, elem, test_id_elem_t, queue_hdr);
        assert(elem);

        /* Unlock ins_queue_mutex */
        if(0 != pthread_mutex_unlock(&shared->ins_queue_mutex))
            TEST_ERROR;

        /* Lookup element */
        if(AXE_id_lookup(shared->id_table, elem->id, (void **)(void *)&lookup_elem, NULL) != AXE_SUCCEED)
            TEST_ERROR;

        /* Verify element */
        if(lookup_elem != elem)
            TEST_ERROR;
        if(OPA_load_int(&elem->phase) != TEST_ID_PHASE_INS)
            TEST_ERROR;

        /* Re-add to inserted queue */
        OPA_Queue_enqueue(&shared->ins_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_lookup_ins_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_remove_gen_helper
 *
 * Purpose:     Repeatedly retrieves ids from gen_queue, performs
 *              AXE_id_remove() on the id, and inserts it into rem_queue.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_remove_gen_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    int i;

    /* Repeatedly remove objects in gen_queue from the id table and add them to
     * rem_queue */
    for(i = 0; i < (REMOVE_GEN_NITER / shared->iter_reduction); i++) {
        /* Lock gen_queue_mutex */
        if(0 != pthread_mutex_lock(&shared->gen_queue_mutex))
            TEST_ERROR;

        /* Retrieve generated element from queue.  If the queue is empty,
         * return. */
        if(OPA_Queue_is_empty(&shared->gen_queue)) {
            if(0 != pthread_mutex_unlock(&shared->gen_queue_mutex))
                TEST_ERROR;
            break;
        } /* end if */

        /* Dequeue element */
        OPA_Queue_dequeue(&shared->gen_queue, elem, test_id_elem_t, queue_hdr);
        assert(elem);

        /* Unlock gen_queue_mutex */
        if(0 != pthread_mutex_unlock(&shared->gen_queue_mutex))
            TEST_ERROR;

        /* Remove element */
        if(AXE_id_remove(shared->id_table, elem->id) != AXE_SUCCEED)
            TEST_ERROR;

        /* Update phase and num_rem_gen */
        if(TEST_ID_PHASE_GEN != OPA_swap_int(&elem->phase, TEST_ID_PHASE_REM))
            TEST_ERROR;
        OPA_incr_int(&shared->num_rem_gen);

        /* Add to removed queue */
        OPA_Queue_enqueue(&shared->rem_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_remove_gen_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_remove_ins_helper
 *
 * Purpose:     Repeatedly retrieves ids from ins_queue, performs
 *              AXE_id_remove() on the id, and inserts it into rem_queue.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_remove_ins_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    test_id_elem_t *elem = NULL;
    int i;

    /* Repeatedly remove objects in ins_queue from the id table and add them to
     * rem_queue */
    for(i = 0; i < (REMOVE_INS_NITER / shared->iter_reduction); i++) {
        /* Lock gen_queue_mutex */
        if(0 != pthread_mutex_lock(&shared->ins_queue_mutex))
            TEST_ERROR;

        /* Retrieve generated element from queue.  If the queue is empty,
         * return. */
        if(OPA_Queue_is_empty(&shared->ins_queue)) {
            if(0 != pthread_mutex_unlock(&shared->ins_queue_mutex))
                TEST_ERROR;
            break;
        } /* end if */

        /* Dequeue element */
        OPA_Queue_dequeue(&shared->ins_queue, elem, test_id_elem_t, queue_hdr);
        assert(elem);

        /* Unlock gen_queue_mutex */
        if(0 != pthread_mutex_unlock(&shared->ins_queue_mutex))
            TEST_ERROR;

        /* Remove element */
        if(AXE_id_remove(shared->id_table, elem->id) != AXE_SUCCEED)
            TEST_ERROR;

        /* Write barrier so the phase is updated after the element is removed */
        OPA_write_barrier();

        /* Update phase and num_rem_gen */
        if(TEST_ID_PHASE_INS != OPA_swap_int(&elem->phase, TEST_ID_PHASE_REM))
            TEST_ERROR;
        OPA_incr_int(&shared->num_rem_ins);

        /* Add to removed queue */
        OPA_Queue_enqueue(&shared->rem_queue, elem, test_id_elem_t, queue_hdr);
    } /* end for */

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_remove_ins_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_iterate_cb
 *
 * Purpose:     Callback function for test_id_iterate_helper().  Verifies
 *              the id's phase is as expected, increments ncalls, and
 *              returns.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
test_id_iterate_cb(void *_elem, void *_ncalls)
{
    test_id_elem_t *elem = (test_id_elem_t *)_elem;
    int *ncalls = (int *)_ncalls;

    /* Make sure the id is marked as inserted */
    if(TEST_ID_PHASE_INS != OPA_load_int(&elem->phase))
        TEST_ERROR;

    /* Increment ncalls */
    (*ncalls)++;

    return AXE_SUCCEED;

error:
    return AXE_FAIL;
} /* end test_id_iterate_cb() */


/*-------------------------------------------------------------------------
 * Function:    test_id_iterate_helper
 *
 * Purpose:     Repeatedly calls AXE_id_iterate on id_table, using
 *              test_id_iterate_cb() as the callback.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
void
test_id_iterate_helper(AXE_engine_t _engine, size_t num_necessary_parents,
    AXE_task_t necessary_parents[], size_t num_sufficient_parents,
    AXE_task_t sufficient_parents[], void *_shared)
{
    test_id_shared_t *shared = (test_id_shared_t *)_shared;
    int ncalls = 0;
    int i;

    /* Repeatedly iterate over all ids in table */
    for(i = 0; i < (ITERATE_NITER / shared->iter_reduction); i++)
        /* Iterate of ids */
        if(AXE_id_iterate(shared->id_table, test_id_iterate_cb, &ncalls) != AXE_SUCCEED)
            TEST_ERROR;

    /* Close */
    OPA_incr_int(&shared->ncomplete);
    return;

error:
    OPA_incr_int(&shared->nfailed);
    return;
} /* end test_id_iterate_helper() */


/*-------------------------------------------------------------------------
 * Function:    test_id_free_cb
 *
 * Purpose:     Callback function for test_id() via AXE_id_free().
 *              Verifies the element and frees it.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
test_id_free_cb(void *_elem, void *_num_ins_free)
{
    test_id_elem_t *elem = (test_id_elem_t *)_elem;
    int *num_ins_free = (int *)_num_ins_free;

    /* Make sure the id is marked as inserted */
    if(TEST_ID_PHASE_INS != OPA_load_int(&elem->phase))
        TEST_ERROR;

    /* Make sure the id has been checked */
    if(!elem->checked)
        TEST_ERROR;

    /* Increment num_gen_free */
    (*num_ins_free)++;

    /* Free elem */
    free(elem);

    return AXE_SUCCEED;

error:
    return AXE_FAIL;
} /* end test_id_free_cb() */


/*-------------------------------------------------------------------------
 * Function:    test_id
 *
 * Purpose:     Creates an id table, launches each test OUTER_NITER times
 *              (using a separate AXE engine), waits for them to complete,
 *              the verifies the results.
 *
 * Return:      void
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
int
test_id(size_t num_threads, size_t num_buckets, size_t num_mutexes,
    int iter_reduction)
{
    AXE_engine_t meta_engine;
    AXE_engine_attr_t engine_attr;
    test_id_shared_t shared;
    test_id_elem_t *elem;
    AXE_task_t task;
    int num_gen = 0;
    int num_ins = 0;
    int num_rem = 0;
    int num_ins_free = 0;
    int i;

    /* Print message */
    printf("num_threads = %zu, num_buckets = %zu, num_mutexes = %zu...\n", num_threads, num_buckets, num_mutexes);
    TESTING("AXE id table");

    /* Create engine attribute and set number of threads */
    if(AXEengine_attr_init(&engine_attr) != AXE_SUCCEED)
        TEST_ERROR;
    if(AXEset_num_threads(&engine_attr, num_threads) != AXE_SUCCEED)
        TEST_ERROR;

    /* Initialize shared data/create id table*/
    if(AXE_id_table_create(num_buckets, num_mutexes, TEST_ID_MIN_ID, TEST_ID_MAX_ID, &shared.id_table) != AXE_SUCCEED)
        TEST_ERROR;
    OPA_Queue_init(&shared.gen_queue);
    if(0 != pthread_mutex_init(&shared.gen_queue_mutex, NULL))
        TEST_ERROR;
    OPA_Queue_init(&shared.ins_queue);
    if(0 != pthread_mutex_init(&shared.ins_queue_mutex, NULL))
        TEST_ERROR;
    OPA_Queue_init(&shared.rem_queue);
    OPA_store_int(&shared.next_nogen, TEST_ID_MAX_ID + 1);
    OPA_store_int(&shared.num_gen, 0);
    OPA_store_int(&shared.num_ins_gen, 0);
    OPA_store_int(&shared.num_ins_nogen, 0);
    OPA_store_int(&shared.num_rem_gen, 0);
    OPA_store_int(&shared.num_rem_ins, 0);
    OPA_store_int(&shared.ncomplete, 0);
    OPA_store_int(&shared.nfailed, 0);
    shared.iter_reduction = iter_reduction;

    /* Create meta engine */
    if(AXEcreate_engine(&meta_engine, &engine_attr) != AXE_SUCCEED)
        TEST_ERROR;

    /* Launch each test OUTER_NITER times */
    for(i = 0; i < OUTER_NITER; i++) {
        /* Launch generate test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_generate_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch insert_gen test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_insert_gen_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch insert_nogen test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_insert_nogen_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch lookup_gen test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_lookup_gen_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch lookup_ins test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_lookup_ins_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch remove_gen test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_remove_gen_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch remove_ins test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_remove_ins_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;

        /* Launch iterate test */
        if(AXEgenerate_task_id(meta_engine, &task) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEcreate_task(meta_engine, task, 0, NULL, 0, NULL, test_id_iterate_helper, &shared, NULL) != AXE_SUCCEED)
            TEST_ERROR;
        if(AXEfinish(meta_engine, task) != AXE_SUCCEED)
            TEST_ERROR;
    } /* end for */

    /* Close meta engine, wait for all tasks to complete */
    if(AXEterminate_engine(meta_engine, TRUE) != AXE_SUCCEED)
        TEST_ERROR;

    /* Make sure all tasks completed, and none failed */
    if(OPA_load_int(&shared.ncomplete) != (8 * OUTER_NITER))
        TEST_ERROR;
    if(OPA_load_int(&shared.nfailed) != 0)
        TEST_ERROR;

    /* Count the number of elements in the generated queue, free them, and empty
     * the queue */
    while(!OPA_Queue_is_empty(&shared.gen_queue)) {
        /* Dequeue element */
        OPA_Queue_dequeue(&shared.gen_queue, elem, test_id_elem_t, queue_hdr);
        num_gen++;

        /* Make sure the phase is generated */
        if(TEST_ID_PHASE_GEN != OPA_load_int(&elem->phase))
            TEST_ERROR;

        /* Free element */
        free(elem);
    } /* end while */

    /* Count the number of elements in the inserted queue, mark them as checked,
     * and empty the queue */
    while(!OPA_Queue_is_empty(&shared.ins_queue)) {
        /* Dequeue element */
        OPA_Queue_dequeue(&shared.ins_queue, elem, test_id_elem_t, queue_hdr);
        num_ins++;

        /* Make sure the phase is inserted */
        if(TEST_ID_PHASE_INS != OPA_load_int(&elem->phase))
            TEST_ERROR;

        /* Mark element as checked */
        elem->checked = TRUE;
    } /* end while */

    /* Count the number of elements in the removed queue, free them, and empty
     * the queue */
    while(!OPA_Queue_is_empty(&shared.rem_queue)) {
        /* Dequeue element */
        OPA_Queue_dequeue(&shared.rem_queue, elem, test_id_elem_t, queue_hdr);
        num_rem++;

        /* Make sure the phase is removed */
        if(TEST_ID_PHASE_REM != OPA_load_int(&elem->phase))
            TEST_ERROR;

        /* Free element */
        free(elem);
    } /* end while */

    /* Verify numbers of elements are as expected */
    if(num_gen != OPA_load_int(&shared.num_gen)
            - OPA_load_int(&shared.num_ins_gen)
            - OPA_load_int(&shared.num_rem_gen))
        TEST_ERROR;
    if(num_ins != OPA_load_int(&shared.num_ins_gen)
            + OPA_load_int(&shared.num_ins_nogen)
            - OPA_load_int(&shared.num_rem_ins))
        TEST_ERROR;
    if(num_rem != OPA_load_int(&shared.num_rem_gen)
            + OPA_load_int(&shared.num_rem_ins))
        TEST_ERROR;

    /* Free id table, verifying the inserted elements once more */
    if(AXE_id_table_free(shared.id_table, test_id_free_cb, &num_ins_free) != AXE_SUCCEED)
        TEST_ERROR;
    if(num_ins != num_ins_free)
        TEST_ERROR;

    /* Close */
    if(AXEengine_attr_destroy(&engine_attr) != AXE_SUCCEED)
        TEST_ERROR;

    PASSED();

    return 0;

error:
    return 1;
} /* end test_id() */


/*-------------------------------------------------------------------------
 * Function:    main
 *
 * Purpose:     Loops over the various test configurations, calling
 *              test_id() for each.
 *
 * Return:      Success: 0
 *              Failure: 1
 *
 * Programmer:  Neil Fortner
 *              April, 2013
 *
 *-------------------------------------------------------------------------
 */
int
main(int argc, char **argv)
{
    int nerrors = 0;
    int i, j;

    /* Initialize framework for limiting maximum number of threads */
    MAX_NTHREADS_INIT(puts("FAILED to initialize!\n"); exit(1));

    /* Loop over different numbers of threads */
    for(i = 0; i < (sizeof(num_threads_g) / sizeof(num_threads_g[0])); i++)
        /* Check if we can run with this many threads */
        MAX_NTHREADS_CHECK_STATIC_IF(num_threads_g[i])
            /* Loop over different numbers of buckets and mutexes */
            for(j = 0; j < (sizeof(num_buckets_g) / sizeof(num_buckets_g[0])); j++)
                /* Launch test */
                nerrors += test_id(num_threads_g[i], num_buckets_g[j], num_mutexes_g[j], iter_reduction_threads_g[i] * iter_reduction_buckets_g[j]);

    /* Free memory allocated for limiting number of threads */
    MAX_NTHREADS_FREE(puts("FAILED to shut down properly!\n"); exit(1));

    /* Print message about failure or success and exit */
    if(nerrors) {
        printf("***** %d TEST%s FAILED! *****\n",
                nerrors, 1 == nerrors ? "" : "S");
        return 1;
    } /* end if */
    else {
        printf("All tests passed.\n");
        return 0;
    } /* end else */
} /* end main () */

