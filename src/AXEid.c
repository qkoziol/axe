/* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * *
 * Copyright by The HDF Group.                                               *
 * All rights reserved.                                                      *
 *                                                                           *
 * This file is part of AXE.  The full AXE copyright notice, including terms *
 * governing use, modification, and redistribution, is contained in the file *
 * COPYING at the root of the source code distribution tree.                 *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */


#include "AXEid.h"


/*
 * Local typedefs
 */
/* Structure for each entry (object) in the id table */
typedef struct AXE_id_entry_t {
    AXE_id_t id;                /* The id of the entry */
    void *obj;                  /* The object associated with the entry.  Can be NULL if the id was generated by AXE_id_generate() but not inserted */
    struct AXE_id_entry_t *next; /* Next entry in the hash bucket */
} AXE_id_entry_t;

/* Structure for each bucket (hash value) in the hash table */
typedef struct AXE_id_bucket_t {
    OPA_ptr_t head;             /* Pointer to the first entry in the bucket (AXE_id_entry_t *) */
    pthread_mutex_t *mutex;     /* Mutex for operations on the bucket */
} AXE_id_bucket_t;

/* Structure for an id table */
struct AXE_id_table_t {
    size_t num_buckets;         /* The number of buckets in the table.  The hash function is simply id % num_buckets */
    AXE_id_bucket_t *buckets;   /* Array of buckets */
    size_t num_mutexes;         /* The number of bucket mutexes in the table */
    pthread_mutex_t *mutexes;   /* Array of bucket mutexes.  Each bucket's "mutex" field points to one of these. */
    AXE_id_t min_id;            /* Minimum id for automatically generated ids */
    AXE_id_t max_id;            /* Maximum id for automatically generated ids */
    AXE_id_t next_id;           /* Next id for automatically generated ids */
    pthread_mutex_t next_id_mutex; /* Mutex automatically generating ids */
    OPA_int_t wrapped;          /* Whether automatic id generation has reached max_id and must use exhaustive search instead */
};


/*-------------------------------------------------------------------------
 * Function:    AXE_id_table_create
 *
 * Purpose:     Creates an empty id table.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 4, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_table_create(size_t num_buckets, size_t num_mutexes, AXE_id_t min_id,
    AXE_id_t max_id, AXE_id_table_t **id_table/*out*/)
{
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(num_buckets > 0);
    assert(num_mutexes > 0);
    assert(max_id >= min_id);
    assert(id_table);

    *id_table = NULL;

    /* Allocate table */
    if(NULL == (*id_table = (AXE_id_table_t *)malloc(sizeof(AXE_id_table_t))))
        ERROR;

    /* Initialize num_buckets, num_mutexes, min_id, max_id, next_id and wrapped
     */
    (*id_table)->num_buckets = num_buckets;
    (*id_table)->num_mutexes = num_mutexes;
    (*id_table)->min_id = min_id;
    (*id_table)->max_id = max_id;
    (*id_table)->next_id = min_id;
    OPA_store_int(&(*id_table)->wrapped, FALSE);

    /* Allocate buckets array */
    if(NULL == ((*id_table)->buckets = (AXE_id_bucket_t *)malloc(num_buckets * sizeof(AXE_id_bucket_t))))
        ERROR;

    /* Allocate mutexes array */
    if(NULL == ((*id_table)->mutexes = (pthread_mutex_t *)malloc(num_mutexes * sizeof(pthread_mutex_t))))
        ERROR;

    /* Initialize buckets */
    for(i = 0; i < num_buckets; i++) {
        OPA_store_ptr(&(*id_table)->buckets[i].head, NULL);
        (*id_table)->buckets[i].mutex = &(*id_table)->mutexes[i % num_mutexes];
    } /* end for */

    /* Initialize mutexes */
    for(i = 0; i < num_mutexes; i++)
        if(0 != pthread_mutex_init(&(*id_table)->mutexes[i], NULL))
            ERROR;
    if(0 != pthread_mutex_init(&(*id_table)->next_id_mutex, NULL))
        ERROR;

done:
    if(ret_value == AXE_FAIL)
        if(*id_table) {
            if((*id_table)->buckets)
                free((*id_table)->buckets);
            if((*id_table)->mutexes)
                free((*id_table)->mutexes);
            free(*id_table);
            *id_table = NULL;
        } /* end if */

    return ret_value;
} /* end AXE_id_table_create() */


/*-------------------------------------------------------------------------
 * Function:    AXE_id_generate
 *
 * Purpose:     Generates an id and inserts it into the table, without an
 *              object.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 4, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_generate(AXE_id_table_t *id_table, AXE_id_t *id)
{
    AXE_id_entry_t *id_entry = NULL;
    AXE_id_entry_t *tmp_id_entry = NULL;
    size_t max_search_id;
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(id_table);
    assert(id);

    /* Create new id entry */
    if(NULL == (id_entry = (AXE_id_entry_t *)malloc(sizeof(AXE_id_entry_t))))
        ERROR;
    id_entry->obj = NULL;
    id_entry->next = NULL;

    /* Lock next id mutex */
    if(0 != pthread_mutex_lock(&id_table->next_id_mutex))
        ERROR;

    /* Check if the id table is "wrapped", necessitating a search for a usable
     * id */
    if(OPA_load_int(&id_table->wrapped)) {
        /* Wrapped, search for an open id.  First loop look for an empty bucket.
         * If not found, then search exhaustively for an id. */
        /* Unlock next id mutex */
        if(0 != pthread_mutex_unlock(&id_table->next_id_mutex))
            ERROR;
        
        /* Only search one loop of the table, or until max_id */
        if((id_table->max_id - id_table->min_id) >= id_table->num_buckets)
            max_search_id = id_table->min_id + id_table->num_buckets - 1;
        else
            max_search_id = id_table->max_id;

        for(id_entry->id = id_table->min_id; id_entry->id <= max_search_id; id_entry->id++)
            if(NULL == OPA_cas_ptr(&id_table->buckets[id_entry->id % id_table->num_buckets].head, NULL, id_entry))
                break;

        /* If we did not find an id, search all possible ids exhaustively */
        if(id_entry->id > max_search_id) {
            for(id_entry->id = id_table->min_id;
                    (id_entry->id <= id_table->max_id);
                    id_entry->id++) {
                /* Calculate index into hash table */
                i = (size_t)(id_entry->id % id_table->num_buckets);

                /* Lock the bucket mutex */
                if(0 != pthread_mutex_lock(id_table->buckets[i].mutex))
                    ERROR;

                /* Attempt to add the entry by compare-and-swap.  Only works if
                 * the bucket is empty.  This is unlikely but could happen if
                 * another thread emptied the bucket.  Must use compare-and-swap
                 * because other threads may add a head entry by
                 * compare-and-swap without taking the mutex. */
                if(NULL == OPA_cas_ptr(&id_table->buckets[i].head, NULL, id_entry))
                    /* Set tmp_id_entry to signal the for loop to exit */
                    tmp_id_entry = id_entry;
                else {
                    /* Scan the list to get to the end.  Also check if the id is
                     * already present.  We know that the list must not be empty
                     * at this point because entries cannot be deleted without
                     * taking the bucket mutex. */
                    tmp_id_entry = OPA_load_ptr(&id_table->buckets[i].head);
                    assert(tmp_id_entry);
                    while(1) {
                        assert(tmp_id_entry->id % id_table->num_buckets == i);
                        if(tmp_id_entry->id == id_entry->id) {
                            tmp_id_entry = NULL;
                            break;
                        } /* end if */
                        if(!tmp_id_entry->next)
                            break;
                        tmp_id_entry = tmp_id_entry->next;
                    } /* end while */

                    /* Add entry if the id is not in use */
                    if(tmp_id_entry)
                        tmp_id_entry->next = id_entry;
                } /* end if */

                /* Unlock the bucket mutex */
                if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
                    ERROR;

                /* If we inserted id_entry, tmp_id_entry will be set, and break
                 * out of the loop.  Must do so here and not in the for
                 * statement so id_entry->id isn't changed after it is inserted.
                 */
                if(tmp_id_entry)
                    break;
            } /* end for */

            /* If we were unable to find an id, return an error */
            if(!tmp_id_entry)
                ERROR;
        } /* end if */
    } /* end if */
    else {
        /* Not wrapped, use and update next_id */
        /* Retrieve id */
        id_entry->id = id_table->next_id;

        /* Update next_id or mark as wrapped, as appropriate */
        if(id_table->next_id == id_table->max_id)
            OPA_store_int(&id_table->wrapped, TRUE);
        else
            id_table->next_id++;

        /* Calculate index into hash table */
        i = (size_t)(id_entry->id % id_table->num_buckets);

        /* Write barrier to make sure id_entry is initialized before it is added
         * to the table */
        OPA_write_barrier();

        /* Attempt to add the entry by compare-and-swap.  Only works if the
         * bucket is empty */
        if(NULL != OPA_cas_ptr(&id_table->buckets[i].head, NULL, id_entry)) {
            /* Bucket was not empty */
            /* Lock the bucket mutex */
            if(0 != pthread_mutex_lock(id_table->buckets[i].mutex))
                ERROR;

            /* Try again to compare-and-swap the head with a pointer, in case it
             * was deleted since the last check.  Must use compare-and-swap
             * because other threads may add a head entry by compare-and-swap
             * without taking the mutex. */
            if(NULL != OPA_cas_ptr(&id_table->buckets[i].head, NULL, id_entry)) {
                /* Scan the list to get to the end.  We know that the list must
                 * not be empty at this point because entries cannot be deleted
                 * without taking the bucket mutex. */
                tmp_id_entry = OPA_load_ptr(&id_table->buckets[i].head);
                assert(tmp_id_entry);
                while(1) {
                    assert(tmp_id_entry->id % id_table->num_buckets == i);
                    assert(tmp_id_entry->id != id_entry->id);
                    if(!tmp_id_entry->next)
                        break;
                    tmp_id_entry = tmp_id_entry->next;
                } /* end while */

                /* Add entry to list*/
                tmp_id_entry->next = id_entry;
            } /* end if */

            /* Unlock the bucket mutex */
            if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
                ERROR;
        } /* end if */

        /* Unlock next id mutex.  Cannot unlock earlier because another thread
         * may mark the table as wrapped, allowing other threads to use this id
         * before this thread adds it to the table. */
        if(0 != pthread_mutex_unlock(&id_table->next_id_mutex))
            ERROR;
    } /* end if */

    /* Return generated id */
    *id = id_entry->id;

done:
    if(ret_value == AXE_FAIL)
        if(id_entry)
            free(id_entry);

    return ret_value;
} /* end AXE_id_generate() */


/*-------------------------------------------------------------------------
 * Function:    AXE_id_insert
 *
 * Purpose:     Inserts an object into an id table with the specified id.
 *              If cur_obj is non-NULL, then if the id already exists,
 *              cur_obj is set to point to the id's object.  Otherwise,
 *              fails if the object already exists.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 4, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_insert(AXE_id_table_t *id_table, AXE_id_t id, void *obj,
    void **cur_obj/*out*/)
{
    AXE_id_entry_t *id_entry = NULL;
    AXE_id_entry_t *tmp_id_entry;
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(id_table);
    assert(obj);

    /* Adjust next_id, if necessary */
    if((id >= id_table->min_id) && (id <= id_table->max_id)
            && !OPA_load_int(&id_table->wrapped)) {
        if(0 != pthread_mutex_lock(&id_table->next_id_mutex))
            ERROR;
        if(id >= id_table->next_id) {
            if(id == id_table->max_id)
                OPA_store_int(&id_table->wrapped, TRUE);
            else
                id_table->next_id = id + 1;
        } /* end if */
        if(0 != pthread_mutex_unlock(&id_table->next_id_mutex))
            ERROR;
    } /* end if */

    /* Calculate index into hash table */
    i = (size_t)(id % id_table->num_buckets);

    /* If the bucket is empty, try to add the new entry directly without taking
     * the mutex */
    if(!OPA_load_ptr(&id_table->buckets[i].head)) {
        /* Create new id entry */
        if(NULL == (id_entry = (AXE_id_entry_t *)malloc(sizeof(AXE_id_entry_t))))
            ERROR;
        id_entry->id = id;
        id_entry->obj = obj;
        id_entry->next = NULL;

        /* Write barrier to make sure id_entry is initialized before it is added
         * to the table */
        OPA_write_barrier();

        /* Try to add to bucket.  Could fail if something was added from another
         * thread since the load above */
        if(NULL == OPA_cas_ptr(&id_table->buckets[i].head, NULL, id_entry))
            goto done;
    } /* end if */

    /* Lock the bucket mutex */
    if(0 != pthread_mutex_lock(id_table->buckets[i].mutex))
        ERROR;

    /* Try again to compare-and-swap the head with a pointer, in case it was
     * deleted since the last check.  Must use compare-and-swap because other
     * threads may add a head entry by compare-and-swap without taking the
     * mutex.  Can temporaily add a bogus pointer because other threads need to
     * take the mutex before dereferencing the pointer. */
    if(NULL == OPA_cas_ptr(&id_table->buckets[i].head, NULL, &i)) {
        /* Create new id entry if it was not created earlier */
        if(!id_entry) {
            if(NULL == (id_entry = (AXE_id_entry_t *)malloc(sizeof(AXE_id_entry_t)))) {
                (void)pthread_mutex_unlock(id_table->buckets[i].mutex);
                ERROR;
            } /* end if */
            id_entry->id = id;
            id_entry->obj = obj;
            id_entry->next = NULL;
        } /* end if */

        /* No write barrier necessary because other threads must take the bucket
         * mutex we currently hold before accessing fields in id_entry */

        /* Add to bucket */
        OPA_store_ptr(&id_table->buckets[i].head, id_entry);

        /* Return */
        if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
            ERROR;
        goto done;
    } /* end if */

    /* Scan the list to get to the end, or find matching empty id entry.  We
     * know that the list must not be empty at this point because entries cannot
     * be deleted without taking the bucket mutex. */
    tmp_id_entry = OPA_load_ptr(&id_table->buckets[i].head);
    assert(tmp_id_entry);
    while(1) {
        assert(tmp_id_entry->id % id_table->num_buckets == i);
        if(tmp_id_entry->id == id) {
            if(tmp_id_entry->obj) {
                /* Object already exists, return object in cur_obj if provided,
                 * otherwise fail */
                if(cur_obj) {
                    *cur_obj = tmp_id_entry->obj;
                    tmp_id_entry = NULL;
                    break;
                } /* end if */
                else {
                    (void)pthread_mutex_unlock(id_table->buckets[i].mutex);
                    ERROR;
                } /* end else */
            } /* end if */
            else {
                /* Found matching empty entry, associate with obj */
                tmp_id_entry->obj = obj;
                tmp_id_entry = NULL;

                /* Report that we did not find a preexisting object */
                if(cur_obj)
                    *cur_obj = NULL;

                break;
            } /* end else */
        } /* end if */
        if(!tmp_id_entry->next)
            break;
        tmp_id_entry = tmp_id_entry->next;
    } /* end while */

    /* If tmp_id_entry is non-NULL here, then a matching empty id_entry was not
     * found and the id has not been inserted.  Append a new id_entry to the end
     * of the list. */
    if(tmp_id_entry) {
        /* Create new id entry if it was not created earlier */
        if(!id_entry) {
            if(NULL == (id_entry = (AXE_id_entry_t *)malloc(sizeof(AXE_id_entry_t)))) {
                (void)pthread_mutex_unlock(id_table->buckets[i].mutex);
                ERROR;
            } /* end if */
            id_entry->id = id;
            id_entry->obj = obj;
            id_entry->next = NULL;
        } /* end if */

        /* No write barrier necessary because other threads must take the bucket
         * mutex we currently hold before accessing fields in id_entry */

        /* Append id_entry to list */
        tmp_id_entry->next = id_entry;

        /* Report that we did not find a preexisting object */
        if(cur_obj)
            *cur_obj = NULL;
    } /* end if */

    /* Unlock the bucket mutex */
    if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
        ERROR;

done:
    if(ret_value == AXE_FAIL)
        if(id_entry)
            free(id_entry);

    return ret_value;
} /* end AXE_id_insert() */


/*-------------------------------------------------------------------------
 * Function:    AXE_id_lookup
 *
 * Purpose:     Retrieves the object with the specified id from an id
 *              table.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 5, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_lookup(AXE_id_table_t *id_table, AXE_id_t id, void **obj,
    _Bool *id_found)
{
    AXE_id_entry_t *id_entry;
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(id_table);
    assert(obj);

    *obj = NULL;

    /* Calculate index into hash table */
    i = (size_t)(id % id_table->num_buckets);

    /* Lock the bucket mutex */
    if(0 != pthread_mutex_lock(id_table->buckets[i].mutex))
        ERROR;

    /* Scan the list to find the id entry */
    for(id_entry = OPA_load_ptr(&id_table->buckets[i].head);
            id_entry && (id_entry->id != id); id_entry = id_entry->next)
        assert(id_entry->id % id_table->num_buckets == i);

    /* Unlock the bucket mutex */
    if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
        ERROR;

    /* Check if we found the id */
    if(id_found)
        *id_found = !!id_entry;

    /* Set *obj to point to obj in id table */
    if(id_entry)
        *obj = id_entry->obj;

done:
    return ret_value;
} /* end AXE_id_lookup() */


/*-------------------------------------------------------------------------
 * Function:    AXE_id_remove
 *
 * Purpose:     Removes the object with the specified id from an id table.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 5, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_remove(AXE_id_table_t *id_table, AXE_id_t id)
{
    AXE_id_entry_t *id_entry;
    AXE_id_entry_t *prev_id_entry = NULL;
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(id_table);

    /* Calculate index into hash table */
    i = (size_t)(id % id_table->num_buckets);

    /* Lock the bucket mutex */
    if(0 != pthread_mutex_lock(id_table->buckets[i].mutex))
        ERROR;

    /* Scan the list to find the id entry */
    for(id_entry = OPA_load_ptr(&id_table->buckets[i].head);
            id_entry && (id_entry->id != id); id_entry = id_entry->next) {
        assert(id_entry->id % id_table->num_buckets == i);
        prev_id_entry = id_entry;
    } /* end for */

    /* Check if we found the id */
    if(!id_entry) {
        (void)pthread_mutex_unlock(id_table->buckets[i].mutex);
        ERROR;
    } /* end if */

    /* Remove id_entry from list */
    if(prev_id_entry)
        prev_id_entry->next = id_entry->next;
    else
        OPA_store_ptr(&id_table->buckets[i].head, id_entry->next);

    /* Unlock the bucket mutex */
    if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
        ERROR;

    /* Free id_entry */
    free(id_entry);

done:
    return ret_value;
} /* end AXE_id_remove() */


/*-------------------------------------------------------------------------
 * Function:    AXE_id_iterate
 *
 * Purpose:     Iterates over all ids in the table, making the specified
 *              for each.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 8, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_iterate(AXE_id_table_t *id_table, AXE_id_iterate_op_t op, void *op_data)
{
    AXE_id_entry_t *id_entry;
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(id_table);
    assert(op);

    /* Iterate over all hash buckets */
    for(i = 0; i < id_table->num_buckets; i++)
        /* Check if the bucket is empty */
        if(OPA_load_ptr(&id_table->buckets[i].head)) {
            /* Lock the bucket mutex */
            if(0 != pthread_mutex_lock(id_table->buckets[i].mutex))
                ERROR;

            /* Load the head element again (could have been deleted) */
            id_entry = OPA_load_ptr(&id_table->buckets[i].head);

            /* Make the callback for each entry in the bucket */
            while(id_entry) {
                assert(id_entry->id % id_table->num_buckets == i);
                if(id_entry->obj && (op(id_entry->obj, op_data) != AXE_SUCCEED)) {
                    (void)pthread_mutex_unlock(id_table->buckets[i].mutex);
                    ERROR;
                } /* end if */
                id_entry = id_entry->next;
            } /* end while */

            /* Unlock the bucket mutex */
            if(0 != pthread_mutex_unlock(id_table->buckets[i].mutex))
                ERROR;
        } /* end if */

done:
    return ret_value;
} /* end AXE_id_iterate() */


/*-------------------------------------------------------------------------
 * Function:    AXE_id_table_free
 *
 * Purpose:     Iterates over all ids in the table, making the specified
 *              callback for each, and destroying the id table in the
 *              process.
 *
 * Return:      Success: AXE_SUCCEED
 *              Failure: AXE_FAIL
 *
 * Programmer:  Neil Fortner
 *              April 8, 2013
 *
 *-------------------------------------------------------------------------
 */
AXE_error_t
AXE_id_table_free(AXE_id_table_t *id_table, AXE_id_iterate_op_t op,
    void *op_data)
{
    AXE_id_entry_t *id_entry;
    AXE_id_entry_t *tmp_id_entry;
    size_t i;
    AXE_error_t ret_value = AXE_SUCCEED;

    assert(id_table);

    /* Iterate over all hash buckets */
    for(i = 0; i < id_table->num_buckets; i++)
        /* Check if the bucket is empty */
        if((id_entry = OPA_load_ptr(&id_table->buckets[i].head))) {
            /* Note we do not need to lock the mutex because this function is
             * not threadsafe with respect to this table */
            /* Make the callback for each entry in the bucket, and free each
             * entry */
            do {
                assert(id_entry->id % id_table->num_buckets == i);
                if(id_entry->obj && (op(id_entry->obj, op_data) != AXE_SUCCEED))
                    ERROR;
                tmp_id_entry = id_entry;
                id_entry = id_entry->next;
#ifndef NDEBUG
                memset(tmp_id_entry, 0, sizeof(*tmp_id_entry));
#endif /* NDEBUG */
                free(tmp_id_entry);
            } while(id_entry);
        } /* end if */

    /* Iterate over all mutexes */
    for(i = 0; i < id_table->num_mutexes; i++)
        if(0 != pthread_mutex_destroy(&id_table->mutexes[i]))
            ERROR;
    if(0 != pthread_mutex_destroy(&id_table->next_id_mutex))
        ERROR;

    /* Free buckets and mutexes */
    free(id_table->buckets);
    free(id_table->mutexes);

    /* Free id table */
#ifndef NDEBUG
    memset(id_table, 0, sizeof(*id_table));
#endif /* NDEBUG */
    free(id_table);

done:
    return ret_value;
} /* end AXE_id_destroy_table() */

